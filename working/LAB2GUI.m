function varargout = LAB2GUI(varargin)

% 1. Load Map

% 2. Load Assets

% 3. Animation Functions

% 4. Main Position and Trajectory Control

% 5. Software Estop

% 6. Hardware Estop

% 7. Teach Buttons

% 8. Teach Panel

% 9. Safety Symbol




% Main Function (Auto generated by MATLAB)

gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @LAB2GUI_OpeningFcn, ...
                   'gui_OutputFcn',  @LAB2GUI_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end


% --- Executes just before LAB2GUI is made visible.
function LAB2GUI_OpeningFcn(hObject, eventdata, handles, varargin)

handles.exitbutton.UserData = 0;
handles.simstarter.UserData = 0;

% Choose default command line output for LAB2GUI
handles.output = hObject;

% Update handles structure
guidata(hObject, handles);

% This sets up the initial plot - only do when we are invisible
% so window can get raised using untitledGUI.
if strcmp(get(hObject,'Visible'),'off')
    plot(rand(5));
end


% UIWAIT makes LAB2GUI wait for user response (see UIRESUME)
% uiwait(handles.figure1);

% --- Outputs from this function are returned to the command line.
function varargout = LAB2GUI_OutputFcn(hObject, eventdata, handles) 

% Get default command line output from handles structure
varargout{1} = handles.output;




%
% 1. Load Map
%


% --- Executes on button press in Load Map.
function map_Callback(hObject, eventdata, handles)
cla 
map = Environments(0.1);
data = guidata(hObject);
data.map = map;
guidata(hObject,data);




%
% 2. Load Assets
%


% --- Executes on button press in Load Assets.
function stuff_Callback(hObject, eventdata, handles)

handles.h = 0.51;
handles.pt = 0.001;
handles.tpt = 0.0001;
handles.current_traces = [];

ws = [-0.5 0.5 -0.5 0.5 0 0.8];
[q2_, q3_] = deal(deg2rad(35), deg2rad(105));
q0 = [-pi/2 q2_ q3_ constrain_joint4(q2_, q3_) 0];

r1 = Dobot(ws, 1);
r1.model.base = transl(-0.1, -0.15, 0.49) * trotz(pi);
r1.model.animate(q0);

r2 = Dobot(ws, 2, true, 2);
r2.model.base = transl(0.2, -0.45, 0.49) * trotz(pi);
r2.model.animate(q0);
hold on

drawnow();
axis equal

pcbs = [];
pcbs{1} = PCB(1, transl(-0.33, 0, handles.h) * trotz(pi/2));
pcbs{2} = PCB(2, transl(-0.31, 0.3, handles.h) * trotz(pi));
pcbs{3} = PCB(3, transl(-0.33, 0.6, handles.h));

view([0 0 1]);
handles.r1 = r1;
handles.r2 = r2;
handles.robot = handles.r1;
handles.pcbs = pcbs;
handles.q0 = q0;

set(handles.teachpannel, 'Visible', 'on');
update_strings(hObject,handles);
guidata(hObject,handles);

set(handles.radiobutton1, 'Visible', 'on');
update_strings(hObject,handles);
guidata(hObject,handles);

set(handles.radiobutton2, 'Visible', 'on');
update_strings(hObject,handles);
guidata(hObject,handles);



%
% 3. Animation Functions
%


function [handles] = animate_traj(handles, dest, model, obj, path, weight, plot, move_ply)
    if ~exist('pt', 'var'), pt = handles.pt; end

    current_pose = model.fkine(model.getpos);
    q = model.getpos;
    [qmatrix, desired] = rmrc(current_pose, dest, q, model, false, path, weight);
    
    if plot == true, plot3(desired(1, :), desired(2, :), desired(3, :), 'y.', 'LineWidth', 1); end % pl
    for i=1:length(qmatrix)
        model.animate(qmatrix(i, :));
        ee = model.fkine(qmatrix(i, :));
        if i == 1, prev_ee = [eye(3), ee(1:3, 4); zeros(1, 3), 1]; else, prev_ee = model.fkine(qmatrix(i-1, :)); end

        if plot == true, plot3(ee(1, 4), ee(2, 4), ee(3, 4), 'b*'); end
        if move_ply == true, obj.MoveMesh(ee);

            if ~isempty(handles.current_traces)
                if i == 1
                    obj_pos = ee(1:3, 4);
                    for j=1:length(handles.current_traces)
                        init_rot = ee(1:3, 1:3);

                        x_ = handles.current_traces{j}.XData;
                        y_ = handles.current_traces{j}.YData;
                        z_ = handles.current_traces{j}.ZData;

                        xyz_ = init_rot * [x_ - obj_pos(1), y_ - obj_pos(2), z_]';

                        handles.current_traces{j}.XData = obj_pos(1) + xyz_(1);
                        handles.current_traces{j}.YData = obj_pos(2) + xyz_(2);
                        handles.current_traces{j}.ZData = xyz_(3);

                    end
                elseif i == length(qmatrix)
                    obj_pos = ee(1:3, 4);
                    for j=1:length(handles.current_traces)

                        x_ = handles.current_traces{j}.XData;
                        y_ = handles.current_traces{j}.YData;
                        z_ = handles.current_traces{j}.ZData;

                        xyz_ = inv(init_rot) * [x_ - obj_pos(1), y_ - obj_pos(2), z_]';

                        handles.current_traces{j}.XData = obj_pos(1) - xyz_(1);
                        handles.current_traces{j}.YData = obj_pos(2) - xyz_(2);
                        handles.current_traces{j}.ZData = xyz_(3);
                    end
                else
                    obj_pos = ee(1:3, 4);
                    prev_pos = prev_ee(1:3, 4);
                    for j=1:length(handles.current_traces)
                        x_ = handles.current_traces{j}.XData;
                        y_ = handles.current_traces{j}.YData;
                        z_ = handles.current_traces{j}.ZData;
                        rot = ee(1:3, 1:3);
                        xyz_ = rot * [obj_pos(1) - prev_pos(1), obj_pos(2) - prev_pos(2), z_]';
%                         disp(xyz_);
                        handles.current_traces{j}.XData = x_ - xyz_(1);
                        handles.current_traces{j}.YData = y_ - xyz_(2);
                        handles.current_traces{j}.ZData = xyz_(3);
                    end
                end
%                 pause(0.5);
            end
        end
        pause(pt);
        if handles.exitbutton.UserData == 1, return; end
    end
    if move_ply == true, obj.MoveMesh(dest); end


function [handles] = animate_dual_traj(handles, qm1, d1, m1, qm2, d2, m2, plot, o, p, w, mp)
    if ~exist('pt', 'var'), pt = handles.pt; end              % pause time
    if ~exist('mp', 'var'), mp = [false, false]; end    % are we moving ply for each model
    if ~exist('o', 'var'), o = [false, false]; end      % obj on end effector
    if ~exist('p', 'var'), p = [1, 1]; end              % path number 1 for a straight line (rmrc)
    if ~exist('w', 'var'), w = [false, false]; end      % weight for curved traj using sin func (rmrc)

    cp1 = m1.fkine(m1.getpos);
    cp2 = m2.fkine(m2.getpos);
    
    [qx1, ds1] = rmrc(cp1, d1, qm1, m1, false, p(1), w(1));
    [qx2, ds2] = rmrc(cp2, d2, qm2, m2, false, p(2), w(2));
    
    [qx1, qx2] = collision_detection(qx1, m1, qx2, m2, false);

    if plot == true, plot3(ds1(1, :), ds1(2, :), ds1(3, :), 'g.', 'LineWidth', 1); end % plot
    if plot == true, plot3(ds2(1, :), ds2(2, :), ds2(3, :), 'y.', 'LineWidth', 1); end % plot
    
    for i=1:length(qx1)
       m1.animate(qx1(i, :));
       ee1 = m1.fkine(qx1(i, :));
       
       m2.animate(qx2(i, :));
       ee2 = m2.fkine(qx2(i, :));

       if plot == true, plot3(ee1(1, 4), ee1(2, 4), ee1(3, 4), 'b*'); end
       if plot == true, plot3(ee2(1, 4), ee2(2, 4), ee2(3, 4), 'r*'); end
       if mp(1) == true, o(1).MoveMesh(ee1); end
       if mp(2) == true, o(2).MoveMesh(ee2); end

       pause(pt);
       if handles.exitbutton.UserData == 1, return; end
    end
    if mp(1) == true, o(1).MoveMesh(ds1); end
    if mp(2) == true, o(2).MoveMesh(ds2); end


function handles = animate_conveyor(handles, obj, start, finish, steps)
    if ~exist('pt', 'var'), pt = 0.02; end
    start_pos = start(1:3, 4)';
    finish_pos = finish(1:3, 4)';

    x = zeros(3, steps);
    theta = zeros(3, 3, steps);

    s = lspb(0,1,steps);
    for i = 1:steps
        x(1,i) = (1-s(i)) * start_pos(1) + s(i) * finish_pos(1);       % Points in x
        x(2,i) = (1-s(i)) * start_pos(2) + s(i) * finish_pos(2);       % Points in y
        x(3,i) = (1-s(i)) * start_pos(3) + s(i) * finish_pos(3);       % Points in z
    end

    for i=1:steps
        if i == 1, prev_ee = [eye(3), obj.pose(1:3, 4); zeros(1, 3), 1]; else, prev_ee = obj.pose; end
        obj.tran(x(:, i)');

        if ~isempty(handles.current_traces)
            obj_pos = obj.pose(1:3, 4);
            prev_pos = prev_ee(1:3, 4);
            for j=1:length(handles.current_traces)
                x_ = handles.current_traces{j}.XData;
                y_ = handles.current_traces{j}.YData;
                z_ = handles.current_traces{j}.ZData;
                rot = obj.pose(1:3, 1:3);
                xyz_ = rot * [obj_pos(1) - prev_pos(1), obj_pos(2) - prev_pos(2), z_]';
%                         disp(xyz_);
                handles.current_traces{j}.XData = x_ + xyz_(1);
                handles.current_traces{j}.YData = y_ + xyz_(2);
                handles.current_traces{j}.ZData = xyz_(3);
            
            end
        end
        pause(pt);
        if handles.exitbutton.UserData == 1, return; end
    end


function [qm1, qm2] = collision_detection(qm1, m1, qm2, m2, plot)
    % pass a joint config to determine if position is in collision
    % present a test scenario where collision detection is used to


    centerPoint = [0, 0, 0];
    radii = [0.07, 0.07, 0.04]/2;

    v = 0.018;
    [Y,Z] = meshgrid(v : 0.001 : v, v : 0.001 : v);
    sizeMat = size(Y);
    X = repmat(radii(1), sizeMat(1), sizeMat(2));

    cubePoints = [X(:), Y(:), Z(:)];
    
    % Make a cube by rotating the single side by 0,90,180,270, and around y to make the top and bottom faces
    cubePoints = [ cubePoints ...
                 ; cubePoints * rotz(pi/2)...
                 ; cubePoints * rotz(pi) ...
                 ; cubePoints * rotz(3*pi/2) ...
                 ; cubePoints * roty(pi/2) ...
                 ; cubePoints * roty(-pi/2)];         
         
    % Plot the cube's point cloud         
%     cubeAtOrigin_h = plot3(cubePoints(:,1), cubePoints(:,2), cubePoints(:,3), 'r.');


    for s = 1 : length(qm1)
        q1 = qm1(s, :);
        q2 = qm2(s, :);
        
        tr1 = zeros(4, 4, m1.n + 1);
        tr2 = zeros(4, 4, m2.n + 1);
        
        tr1(:, :, 1) = m1.base;
        tr2(:, :, 1) = m2.base;
        
        L1 = m1.links;
        L2 = m2.links;

        for i = 1 : m1.n
            tr1(:, :, i+1) = tr1(:, :, i) * trotz(q1(i)) * transl(0,0,L1(i).d) * transl(L1(i).a,0,0) * trotx(L1(i).alpha);
            tr2(:, :, i+1) = tr2(:, :, i) * trotz(q2(i)) * transl(0,0,L2(i).d) * transl(L2(i).a,0,0) * trotx(L2(i).alpha);
        end

        % cubes from m2 in links of m1
        for i = 1 : size(tr1, 3)
            cubePointsAndOnes = [inv(tr2(:, :, i)) * [cubePoints, ones(size(cubePoints, 1), 1)]']';
            updatedCubePoints = cubePointsAndOnes(:, 1:3);
            algebraicDist = GetAlgebraicDist(updatedCubePoints, tr1(1:3, 4, i)', radii);
            pointsInside = find(algebraicDist < 1);
%             disp(['There are ', num2str(size(pointsInside,1)),' points inside the ', num2str(i),'th ellipsoid']);
        end

        % cubes from m1 in links of m2
        for i = 1 : size(tr2, 3)
            cubePointsAndOnes = [inv(tr1(:, :, i)) * [cubePoints, ones(size(cubePoints, 1), 1)]']';
            updatedCubePoints = cubePointsAndOnes(:, 1:3);
            algebraicDist = GetAlgebraicDist(updatedCubePoints, tr2(1:3, 4, i)', radii);
            pointsInside = find(algebraicDist < 1);
%             disp(['There are ', num2str(size(pointsInside,1)),' points inside the ', num2str(i),'th ellipsoid']);
        end
    end
        


%     for i = 1:length(qm1(1, :))
%         m1.points{i} = [X_(:), Y_(:), Z_(:)];
%         m1.faces{i} = delaunay(m1.points{i});
% 
%         m2.points{i} = [X_(:), Y_(:), Z_(:)];
%         m2.faces{i} = delaunay(m2.points{i});
%     end

    if plot == true, m1.plot3d(qm1(1, :)); end


function [handles] = trace_path(handles, obj, model, plot)
    if ~exist('pt', 'var'), pt = handles.tpt; end

    plt = [];
     if obj.type == 1
        
        tfs = zeros(4, 4, 3);
        tfs(:, :, 1) = transl(-0.05, -0.02, 0.005);

        tfs(:, :, 2) = transl(0.1, 0, 0);
%         tfs(:, :, 3) = transl(-0.045, -0.02, 0);
%         tfs(:, :, 4) = transl(0, -0.02, 0);
%         tfs(:, :, 5) = transl(0.045, 0.02, 0);
% 
%         tfs(:, :, 6) = transl(0, -0.02, 0);
%         tfs(:, :, 7) = transl(0, -0.02, 0);
%         tfs(:, :, 8) = transl(-0.035, -0.0175, 0);
% 
%         tfs(:, :, 9) = transl(0, -0.02, 0);
%         tfs(:, :, 10) = transl(0.035, 0.0175, 0);
%         
%         tfs(:, :, 11) = transl(0.005, -0.02, 0);
% 
%         tfs(:, :, 12) = transl(-0.02, 0, 0);
%         tfs(:, :, 13) = transl(0, -0.02, 0);
%         tfs(:, :, 14) = transl(0.02, 0, 0);
%         
%         tfs(:, :, 15) = transl(0, -0.02, 0);
%         tfs(:, :, 16) = transl(-0.025, 0, 0);
%         tfs(:, :, 17) = transl(-0.025, 0.025, 0);
%         tfs(:, :, 18) = transl(0, -0.05, 0);
%         tfs(:, :, 19) = transl(0.045, 0, 0);
        
        tfs(:, :, 3) = transl(-0.1, -0.1, 0);
        l = size(tfs);
        for i=1:l(3)
            cp = model.fkine(model.getpos);
            if i == 1 || i == 3
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 1, false);
                plt = loop_qmatrix(qmatrix, model, plt, false, false);
                % if plot == true, plot3(desired(1, :), desired(2, :), desired(3, :), 'y.', 'LineWidth', 1); end % plot

            else
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 1, false);
                plt = loop_qmatrix(qmatrix, model, plt, true, 'c*');
            end
        end

    elseif obj.type == 2 % More complex shape
        tfs = zeros(4, 4, 20);

        tfs(:, :, 1) = transl(0.04, 0.03, 0.005);

        tfs(:, :, 2) = transl(-0.05, 0, 0);
        tfs(:, :, 3) = transl(0, -0.02, 0);
        tfs(:, :, 4) = transl(-0.05, 0, 0);

        tfs(:, :, 5) = transl(0, -0.01, 0);

        tfs(:, :, 6) = transl(0.06, 0, 0);
        tfs(:, :, 7) = transl(0, 0.015, 0);
        tfs(:, :, 8) = transl(0.02, 0, 0);

        tfs(:, :, 9) = transl(0, -0.015, 0);
        tfs(:, :, 10) = transl(-0.01, 0, 0);
        tfs(:, :, 11) = transl(0, -0.01, 0);
        tfs(:, :, 12) = transl(-0.07, 0, 0);

        tfs(:, :, 13) = transl(0.09, -0.06, 0);
        tfs(:, :, 14) = transl(-0.09, 0.02, 0);
        tfs(:, :, 15) = transl(0, 0.02, 0);

        tfs(:, :, 16) = transl(0.02, 0, 0);
        tfs(:, :, 17) = transl(0, -0.02, 0);
        tfs(:, :, 18) = transl(0.04, 0, 0);
        tfs(:, :, 19) = transl(0.02, 0, 0);
        
        tfs(:, :, 20) = transl(-0.15, -0.15, 0);
        
        l = size(tfs);
        for i=1:l(3)
            cp = model.fkine(model.getpos);
            if i == 1 || i == 5 ||i == 9 || i == 13 || i == 16 || i == 20
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 1, false);
                plt = loop_qmatrix(qmatrix, model, plt, false, false);
                % if plot == true, plot3(desired(1, :), desired(2, :), desired(3, :), 'y.', 'LineWidth', 1); end % plot

            else
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 1, false);
                plt = loop_qmatrix(qmatrix, model, plt, true, 'm*');
            end
        end

    elseif obj.type == 3 % Circular shape

        tfs = zeros(4, 4, 7);
        tfs(:, :, 1) = transl(-0.045, 0.05, 0.005);

        tfs(:, :, 2) = transl(0.1, -0.1, 0);
        tfs(:, :, 3) = transl(-0.01, 0.01, 0);

        tfs(:, :, 4) = transl(-0.08, 0.08, 0);
        tfs(:, :, 5) = transl(0.01, -0.01, 0);

        tfs(:, :, 6) = transl(0.06, -0.06, 0);
        tfs(:, :, 7) = transl(-0.01, 0.01, 0);

        tfs(:, :, 8) = transl(-0.04, 0.04, 0);
        tfs(:, :, 9) = transl(0.01, -0.01, 0);

        tfs(:, :, 10) = transl(0, -0.04, 0);
        tfs(:, :, 11) = transl(-0.25, -0.15, 0);
        
        l = size(tfs);
        for i=1:l(3)
            cp = model.fkine(model.getpos);
            if i == 1 ||  i == 3 || i == 5 || i == 7 || i == 9 || i == 10 || i == 11
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 1, false);
                plt = loop_qmatrix(qmatrix, model, plt, false, false);
            elseif i == 2
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 4, -0.05);
                plt = loop_qmatrix(qmatrix, model, plt, true, 'g*');
            elseif i == 4
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 4, 0.05);
                plt = loop_qmatrix(qmatrix, model, plt, true, 'g*');
            elseif i == 6
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 4, -0.025);
                plt = loop_qmatrix(qmatrix, model, plt, true, 'g*');
            elseif i == 8
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 4, 0.025);
                plt = loop_qmatrix(qmatrix, model, plt, true, 'g*');
            else
                [qmatrix, desired] = rmrc(cp, cp + tfs(:, :, i), model.getpos, model, false, 1, false);
                plt = loop_qmatrix(qmatrix, model, plt, true, 'g*');
            end
        end
     end
     
     disp(strcat(['    Completed trace path for PCB ', num2str(obj.type)]));
     if handles.exitbutton.UserData == 1, pause(1); closereq(); return; end
%      pause(6);
%      keyboard;

    handles.current_traces = plt;
 

function plots = loop_qmatrix(qmatrix, model, plots, plot, linespec)
    if ~exist('linespec', 'var'), linespec = 'b*'; end
    if ~exist('pt', 'var'),  pt = 0.005; end

    for i=1:length(qmatrix)
           model.animate(qmatrix(i, :));
           ee = model.fkine(qmatrix(i, :));
           if plot == true
               plt = plot3(ee(1, 4), ee(2, 4), ee(3, 4), linespec, 'MarkerSize', 0.1); 
               plots{length(plots)+1} = plt;
           end
           pause(pt);
    end


function algebraicDist = GetAlgebraicDist(points, centerPoint, radii)

algebraicDist = ((points(:,1)-centerPoint(1))/radii(1)).^2 ...
              + ((points(:,2)-centerPoint(2))/radii(2)).^2 ...
              + ((points(:,3)-centerPoint(3))/radii(3)).^2;




%
% 4. Main Position and Trajectory Control
%


% --- Executes on button press in simstarter.
function simstarter_Callback(hObject, eventdata, handles)

if isfield(handles,'r1')
    handles.simstarter.UserData = 1;
    guidata(hObject, handles)
    i = 1;
    l = 1;
    
    while (1)
        
        steps = 9;
        
        if l > 3, break; end
        if handles.exitbutton.UserData == 1, break; end
        
        if mod(i, steps * l) == 0
            l = l + 1;
        else
            handles = sequences(i, steps, handles);
            guidata(hObject, handles);
            i = i + 1;
        end
    end
    
    if handles.exitbutton.UserData == 1
        disp('Returning out of sim start')
        closereq();
        %     return;
    end
else
    errordlg('Please load the map and assets first','Asset error');
end



function [handles] = sequences(i, steps, handles)
    % workspace origin (where transporter and laser could collide)
    ws_origin = transl(-0.03, -0.42, handles.h);
    
    % transporter stow pos when laser operating
    stow_away = [ws_origin(1:3, 1:3), ws_origin(1:3, 4) - [0.1; -0.1; 0]; zeros(1, 3), 1;];
    
    % exit position
    conv_out = transl(-0.3, -0.4, handles.h);

    if mod(i, steps) == 1
        disp(' ')
        disp(strcat(['PCB: ', num2str(ceil(i/steps))]));

        disp('a. SEQ -- Move R1 from q0 to pcb')
        handles = animate_traj(handles, handles.pcbs{ceil(i / steps)}.pose, handles.r1.model, false, 1, 0, false, false);

    elseif mod(i, steps) == 2
        disp('b. SEQ -- Move R1 to ws origin')
        handles = animate_traj(handles, ws_origin, handles.r1.model, handles.pcbs{ceil(i / steps)}, 5, -0.1, false, true);

%     disp('c. SEQ -- Move R1 to stow away pose for laser operation')
%     animate_traj(handles, stow_away, handles.r1.model, false, 1, false, false, false)
%     
%     disp('d. SEQ - Move R2 to ws origin')
%     animate_traj(handles, ws_origin, handles.r2.model, false, 1, false, false, false)

    elseif mod(i, steps) == 3
        disp('c. & d. DUAL - Move R1 to stow away pose for laser operation & Move R2 to ws origin')
        handles = animate_dual_traj(handles, handles.r1.model.getpos, stow_away, handles.r1.model, handles.r2.model.getpos, ws_origin, handles.r2.model, false);

    elseif mod(i, steps) == 4
        % Insert trace paths here
        handles = trace_path(handles, handles.pcbs{ceil(i / steps)}, handles.r2.model, true);

    elseif mod(i, steps) == 5
        disp('f. Move R2 to q0')
        handles = animate_traj(handles, handles.r2.model.fkine(handles.q0), handles.r2.model, false, 1, false, false, false);
        handles.r2.model.animate(handles.q0);

    elseif mod(i, steps) == 6
        disp('g. Move R1 from stow away to pcb1')
        handles = animate_traj(handles, handles.pcbs{ceil(i / steps)}.pose, handles.r1.model, handles.pcbs{ceil(i / steps)}, 1, false, false, false);

    elseif mod(i, steps) == 7
        disp('h. Move R1 from ws origin to conveyor out with pcb1')
        handles = animate_traj(handles, conv_out, handles.r1.model, handles.pcbs{ceil(i / steps)}, 1, false, false, true);

    elseif mod(i, steps) == 8
        disp('i. Move R1 from conveyor out to q0')
        handles = animate_traj(handles, handles.r1.model.fkine(handles.q0), handles.r1.model, false, 5, -0.2, false, false);

    elseif mod(i, steps) == 0
        % 8a. Animate Conveyor
        handles = animate_conveyor(handles, handles.pcbs{ceil(i / steps)}, handles.pcbs{ceil(i / steps)}.pose, handles.pcbs{ceil(i / steps)}.pose - transl(0.7, 0, 0), 30);
        pause(1);
        disp('deleting trace');
        for a=1:length(handles.current_traces), delete(handles.current_traces{a}); end
        handles.current_traces = [];
        handles.pcbs{ceil(i/steps)}.mesh_h.Vertices = [];
        
        if ceil(i / steps) < 2 handles = animate_conveyor(handles, handles.pcbs{2}, handles.pcbs{2}.pose, handles.pcbs{2}.pose - transl(0, 0.3, 0), 30); end
        if ceil(i / steps) < 3 handles = animate_conveyor(handles, handles.pcbs{3}, handles.pcbs{3}.pose, handles.pcbs{3}.pose - transl(0, 0.3, 0), 30); end
        
        pause(1.5);
        
    end




% 
% 5. Software Estop
%


% --- Executes on continue button press in cont.
function cont_Callback(hObject, eventdata, handles)

if handles.cont.Value == 1
    if handles.estop.Value == 1
        disp('turning off estop')
        set(handles.stoptext, 'Visible','off');
    else
        disp('estop already off')
    end
   
end
guidata(hObject,handles);


% --- Executes on button press in estop.
function estop_Callback(hObject, eventdata, handles)

if handles.estop.Value == 1
    handles.cont.Value = 1;
    set(handles.stoptext, 'Visible','on');
    set(handles.stoptext, 'BackgroundColor','red');
    disp('EStop engaged')
    pt = 0.5;
    while 1
        disp('awaiting input . . .');
        
        if isfield(handles,'s')
            try
                checkhardwarestop(hObject,handles);
            catch me
            end
        end
        if handles.cont.Value == 0, handles.estop.Value = 0; break;
        else, pause(pt); continue; end
    end

end

if handles.estop.Value == 0
    set(handles.stoptext, 'Visible','off');
end

guidata(hObject, handles);


% --- Executes on button press in estop.
function exit_Callback(hObject, eventdata, handles)

if handles.exitbutton.Value == 1
    handles.exitbutton.UserData = 1;
    disp('Exiting GUI')
    try
        stop(handles.timer);
    catch me
        disp(me);
    end
    try
        delete(timerfindall)
    catch me
        disp(me);
    end
    handles.exitbutton.Value = 0;
    guidata(hObject, handles);
    if handles.simstarter.UserData == 0, closereq(); end
    try if handles.simstarter.UserData == 1, closereq(); end; catch e; end
end

% --- Executes on button press in exitbutton.
function exitbutton_Callback(hObject, eventdata, handles)
% hObject    handle to exitbutton (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
if handles.exitbutton.Value == 1
    handles.exitbutton.UserData = 1;
    disp('Exiting GUI')
    try
        stop(handles.timer);
    catch me
        disp(me);
    end
    try
        delete(timerfindall)
    catch me
        disp(me);
    end
    handles.exitbutton.Value = 0;
    guidata(hObject, handles);
    if handles.simstarter.UserData == 0, closereq(); end
    try if handles.simstarter.UserData == 1, closereq(); end; catch e; end
end
    
%
% 6. Hardware Estop
%


% --- Executes on button press in connect_b.
function connect_b_Callback(hObject, eventdata, handles)

path = get(handles.path,'String');

try
    s = serialport(path,9600); % connect to hardware through serial
    handles.s = s;
    handles.timer = timer('ExecutionMode', 'fixedRate', 'Period', 0.5,'TimerFcn', {@checkhardwarestop,hObject,handles});
    handles.timer.start;
catch me
    disp(me);
    errordlg('Serial device could not be found in specified path','Serial Path Error');
end
guidata(hObject,handles);


function checkhardwarestop(~,~,hObject,handles)
% polls serial port to see the state of the estop
flush(handles.s);
data = read(handles.s,1,"char")
% arduino code send 1 if estop is on and 0 if estop is turned off
% update the variables
eventdata = 0;
if data == "1"
    handles.estop.Value = 1;
%     set(handles.stoptext, 'Visible','on');
%     set(handles.stoptext, 'BackgroundColor','red');
    guidata(hObject,handles);
    estop_Callback(hObject, eventdata, handles);
end
if data == "0"
    handles.estop.Value = 0;
%     set(handles.stoptext, 'BackgroundColor','green');
    guidata(hObject,handles);
    estop_Callback(hObject, eventdata, handles);
end

guidata(hObject,handles);


% --- Executes during object creation, after setting all properties.
function path_CreateFcn(hObject, eventdata, handles)
% Hint: edit conr2.model.base + transl(-0.3, -0.05, 0)trols usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

%
% 7. Teach Buttons
% 


% --- Executes on button press in radiobutton1.
function radiobutton1_Callback(hObject, eventdata, handles)
handles.radiobutton2.Value = 0;
handles.robot = handles.r1;
update_strings(hObject,handles)
disp('Teach Panel switched to Robot 1')


% --- Executes on button press in radiobutton2.
function radiobutton2_Callback(hObject, eventdata, handles)
handles.radiobutton1.Value = 0;
handles.robot = handles.r2;
update_strings(hObject,handles)
disp('Teach Panel switched to Robot 2')


% Q's

% --- Executes on button press in q1minus.
function q1minus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
q(1,1) = q(1,1)-0.1;
handles.robot.model.animate(q);
update_strings(hObject,handles)
guidata(hObject,handles);


% --- Executes on button press in q2minus.
function q2minus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
q(1,2) = q(1,2)-0.1;
q(1,4) = constrain_joint4(q(1,2),q(1,3));
handles.robot.model.animate(q);
update_strings(hObject,handles)
guidata(hObject,handles);


% --- Executes on button press in q3minus.
function q3minus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
q(1,3) = q(1,3)-0.1;
q(1,4) = constrain_joint4(q(1,2),q(1,3));
handles.robot.model.animate(q);
update_strings(hObject,handles)
guidata(hObject,handles);


% --- Executes on button press in q4minus.
function q4minus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
q(1,5) = q(1,5)-0.1;
handles.robot.model.animate(q);
update_strings(hObject,handles)
guidata(hObject,handles);


% --- Executes on button press in q1plus.
function q1plus_Callback(hObject, eventdata, handles)

q = handles.robot.model.getpos;
q(1,1) = q(1,1)+0.1;
handles.robot.model.animate(q);
update_strings(hObject,handles)
guidata(hObject,handles);

% --- Executes on button press in q2plus.
function q2plus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
q(1,2) = q(1,2)+0.1;
q(1,4) = constrain_joint4(q(1,2),q(1,3));
handles.robot.model.animate(q);
update_strings(hObject,handles)
guidata(hObject,handles);

% --- Executes on button press in q3plus.
function q3plus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
q(1,3) = q(1,3)+0.1;
q(1,4) = constrain_joint4(q(1,2),q(1,3));
handles.robot.model.animate(q);
update_strings(hObject,handles)
guidata(hObject,handles);

% --- Executes on button press in q4plus.
function q4plus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
q(1,5) = q(1,5)+0.1;
handles.robot.model.animate(q);
update_strings(hObject,handles)
guidata(hObject,handles);


% Cartesian


% --- Executes on button press in xminus.
function xminus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
tr = handles.robot.model.fkine(q);
tr(1,4) = tr(1,4)-0.01;
update_strings(hObject,handles);
newq = handles.robot.model.ikcon(tr,q);
handles.robot.model.animate(newq);
guidata(hObject,handles);


% --- Executes on button press in yminus.
function yminus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
tr = handles.robot.model.fkine(q);
tr(2,4) = tr(2,4)-0.01;
update_strings(hObject,handles)
newq = handles.robot.model.ikcon(tr,q);
handles.robot.model.animate(newq);
guidata(hObject,handles);

% --- Executes on button press in zminus.
function zminus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
tr = handles.robot.model.fkine(q);
tr(3,4) = tr(3,4)-0.01;
update_strings(hObject,handles)
newq = handles.robot.model.ikcon(tr,q);
handles.robot.model.animate(newq);
guidata(hObject,handles);


% --- Executes on button press in xplus.
function xplus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
tr = handles.robot.model.fkine(q);
tr(1,4) = tr(1,4)+0.01;
update_strings(hObject,handles)
newq = handles.robot.model.ikcon(tr,q);
handles.robot.model.animate(newq);
guidata(hObject,handles);


% --- Executes on button press in yplus.
function yplus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
tr = handles.robot.model.fkine(q);
tr(2,4) = tr(2,4)+0.01;
update_strings(hObject,handles)
newq = handles.robot.model.ikcon(tr,q);
handles.robot.model.animate(newq);
guidata(hObject,handles);


% --- Executes on button press in zplus.
function zplus_Callback(hObject, eventdata, handles)
q = handles.robot.model.getpos;
tr = handles.robot.model.fkine(q);
tr(3,4) = tr(3,4)+0.01;
update_strings(hObject,handles)
newq = handles.robot.model.ikcon(tr,q);
handles.robot.model.animate(newq);
guidata(hObject,handles);




%
% 8. Update Teach Panel
%


function update_strings(hObject,handles)
% function updates the all the strings on the jogging UI
q = handles.robot.model.getpos;

set(handles.text3, 'String', num2str(q(1,1), 3));
set(handles.text4, 'String', num2str(q(1,2), 3));
set(handles.text5, 'String', num2str(q(1,3), 3));
set(handles.text6, 'String', num2str(q(1,5), 3));

tr = handles.robot.model.fkine(q);

set(handles.text7, 'String', num2str(tr(1,4), 3));
set(handles.text8, 'String', num2str(tr(2,4), 3));
set(handles.text9, 'String', num2str(tr(3,4), 3));

guidata(hObject,handles);




%
% 9. Safety Symbol
%





% --- Executes on button press in checkbox1.
function checkbox1_Callback(hObject, eventdata, handles)
value = get(hObject,'Value');
if value == 1
        
    if isfield(handles,'r1')
        set(handles.vspannel, 'Visible', 'on');
        
        handles.centr = transl(-0.1, 0, 0.49);
        handles.vsrot = [0,0,0];
        handles.P = getP(handles.centr,0.05,2);
        hold on
        handles.target = Target(handles.centr);
        updatevsstrings(hObject, eventdata,handles)
    
        handles.cam = CentralCamera('focal', 0.08, 'pixel', 10e-5, ...
            'resolution', [1024 1024], 'centre', [512 512],'name', 'docam');
        Tc0= handles.r1.model.fkine(handles.r1.model.getpos)*trotx(pi);
        handles.cam.plot_camera('Tcam',Tc0, 'label','scale',0.025);
        
        handles.pStar = [362 662;512 512];
        handles.P = getP(handles.centr,0.05,2);
        updatecamfeed(hObject, eventdata, handles);
        
    else
        errordlg('Please load the map and assets first','Asset error');
        handles.checkbox1.Value = 0;
    end
else
    set(handles.vspannel, 'Visible', 'off');
    if isfield(handles,'target')
        handles.target.DeleteMesh;
    end
end

guidata(hObject,handles);

% updates the camera image figure
function updatecamfeed(hObject, eventdata, handles)

Tc0= handles.r1.model.fkine(handles.r1.model.getpos)*trotx(pi);
handles.cam.clf()
handles.cam.plot(handles.pStar, '*'); 
handles.cam.hold(true);
handles.cam.plot(handles.P(:,1), 'Tcam', Tc0, 'o')
handles.cam.plot(handles.P(:,2), 'Tcam', Tc0, 'x')


guidata(hObject,handles);

% --- Executes on button press in vsstart.
function vsstart_Callback(hObject, eventdata, handles)
value = get(hObject,'Value');

while value == 1
    Tc0 = handles.r1.model.fkine(handles.r1.model.getpos) * trotx(pi);
    q0 = handles.r1.model.getpos;
    
    p = handles.cam.plot(handles.P,'Tcam',Tc0);
    if ~(length(handles.pStar) > length(p)) %if we can see all the points in camera view
        realDepth = getDist(handles.target.pose,Tc0)
        if (realDepth < 0.1503)
            % perform movement.
            disp('vsloop');
            vsloop(handles.cam,realDepth,0.2,25,handles.pStar,handles.P,handles.r1,q0');
        else
            disp('safe');
        end
    else
        disp('cant see symbol');
    end
    
    value = get(hObject,'Value');
end



guidata(hObject,handles);

% --- Executes on button press in vsminusx.
function vsminusx_Callback(hObject, eventdata, handles)
pose = handles.target.pose;
pose = pose * transl(-0.01,0,0);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);


% --- Executes on button press in vsminusy.
function vsminusy_Callback(hObject, eventdata, handles)
pose = handles.target.pose;
pose = pose * transl(0,-0.01,0);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);


% --- Executes on button press in vsminusz.
function vsminusz_Callback(hObject, eventdata, handles)
pose = handles.target.pose;
pose = pose * transl(0,0,-0.01);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);


% --- Executes on button press in vsplusx.
function vsplusx_Callback(hObject, eventdata, handles)
pose = handles.target.pose;
pose = pose * transl(0.01,0,0);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);


% --- Executes on button press in vsplusy.
function vsplusy_Callback(hObject, eventdata, handles)
pose = handles.target.pose;
pose = pose * transl(0,0.01,0);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);


% --- Executes on button press in vsplusz.
function vsplusz_Callback(hObject, eventdata, handles)
pose = handles.target.pose;
pose = pose * transl(0,0,0.01);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);


% --- Executes on button press in vsminusroll.
function vsminusroll_Callback(hObject, eventdata, handles)
pose = handles.target.pose;
pose = pose * trotx(-0.174533);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

value = handles.vsrot(1,1);
value = value -0.1;
handles.vsrot(1,1) = value;

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);


% --- Executes on button press in vsminuspitch.
function vsminuspitch_Callback(hObject, eventdata, handles)
% hObject    handle to vsminuspitch (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
pose = handles.target.pose;
pose = pose * troty(-0.174533);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

value = handles.vsrot(1,2);
value = value -0.1;
handles.vsrot(1,2) = value;

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);


% --- Executes on button press in vsminusyaw.
function vsminusyaw_Callback(hObject, eventdata, handles)
% hObject    handle to vsminusyaw (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
pose = handles.target.pose;
pose = pose * trotz(-0.174533);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

value = handles.vsrot(1,3);
value = value -0.1;
handles.vsrot(1,3) = value;

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);


% --- Executes on button press in vsplusroll.
function vsplusroll_Callback(hObject, eventdata, handles)
% hObject    handle to vsplusroll (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
pose = handles.target.pose;
pose = pose * trotx(0.174533);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

value = handles.vsrot(1,1);
value = value +0.1;
handles.vsrot(1,1) = value;

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);

% --- Executes on button press in vspluspitch.
function vspluspitch_Callback(hObject, eventdata, handles)
% hObject    handle to vspluspitch (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
pose = handles.target.pose;
pose = pose * troty(0.174533);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

value = handles.vsrot(1,2);
value = value +0.1;
handles.vsrot(1,2) = value;

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);

% --- Executes on button press in vsplusyaw.
function vsplusyaw_Callback(hObject, eventdata, handles)
% hObject    handle to vsplusyaw (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
pose = handles.target.pose;
pose = pose * trotz(0.174533);
handles.target.MoveMesh(pose);

handles.P = getP(pose,0.05,2); % get the points after moving target
updatecamfeed(hObject, eventdata, handles); % update camera image

value = handles.vsrot(1,3);
value = value +0.1;
handles.vsrot(1,3) = value;

updatevsstrings(hObject, eventdata,handles);
guidata(hObject,handles);

function updatevsstrings(hObject, eventdata,handles)
% function updates the text labels for in the vspannel
tr = handles.target.pose;
set(handles.vsx, 'String',tr(1,4));
set(handles.vsy, 'String',tr(2,4));
set(handles.vsz, 'String',tr(3,4));

value = handles.vsrot;
set(handles.vsroll, 'String',value(1,1));
set(handles.vspitch, 'String',value(1,2));
set(handles.vsyaw, 'String',value(1,3));

guidata(hObject,handles);






function path_Callback(hObject, eventdata, handles)
% hObject    handle to path (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of path as text
%        str2double(get(hObject,'String')) returns contents of path as a double
